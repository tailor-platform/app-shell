import type { PageFile } from "./scanner";

/**
 * Extract dynamic parameters from a route path.
 *
 * @example
 * extractParams("/orders/:id") → ["id"]
 * extractParams("/orders/:orderId/items/:itemId") → ["orderId", "itemId"]
 * extractParams("/docs/*slug") → ["slug"]
 * extractParams("/dashboard") → []
 */
export function extractParams(routePath: string): string[] {
  const params: string[] = [];

  // Match :param patterns (dynamic segments)
  const dynamicMatches = routePath.matchAll(/:([^/?]+)/g);
  for (const match of dynamicMatches) {
    params.push(match[1]);
  }

  // Match *param patterns (catch-all segments)
  const catchAllMatches = routePath.matchAll(/\*([^/?]+)/g);
  for (const match of catchAllMatches) {
    params.push(match[1]);
  }

  return params;
}

/**
 * Generate TypeScript code for RouteParams type entry.
 *
 * @example
 * generateParamsType(["id"]) → "{ id: string }"
 * generateParamsType(["orderId", "itemId"]) → "{ orderId: string; itemId: string }"
 * generateParamsType([]) → "{}"
 */
export function generateParamsType(params: string[]): string {
  if (params.length === 0) {
    return "{}";
  }

  const entries = params.map((p) => `${p}: string`).join("; ");
  return `{ ${entries} }`;
}

/**
 * Generate the typed routes file content.
 *
 * @param pages - Array of page files with route information
 * @returns TypeScript code string for routes.generated.ts
 */
export function generateTypedRoutesCode(pages: PageFile[]): string {
  const routeEntries: string[] = [];

  // Sort pages by route path for consistent output
  const sortedPages = [...pages].sort((a, b) => {
    const pathA = a.routePath || "";
    const pathB = b.routePath || "";
    return pathA.localeCompare(pathB);
  });

  for (const page of sortedPages) {
    const routePath = page.routePath ? `/${page.routePath}` : "/";
    const params = extractParams(routePath);
    const paramsType = generateParamsType(params);

    routeEntries.push(`  "${routePath}": ${paramsType};`);
  }

  return `// Auto-generated by @tailor-platform/app-shell-vite-plugin
// Do not edit manually
/* eslint-disable @typescript-eslint/no-empty-object-type */

import { createTypedPaths } from "@tailor-platform/app-shell";

/**
 * Route parameter definitions for file-based routing.
 * Maps route paths to their required parameters.
 *
 * This type is automatically generated and updated by the app-shell vite plugin
 * during \`vite build\` or \`vite dev\`. The plugin scans your pages directory
 * and generates entries for each route based on your file structure.
 *
 * Do not edit this file manually - your changes will be overwritten.
 */
export type GeneratedRouteParams = {
${routeEntries.join("\n")}
};

/**
 * Type-safe path builder for navigating between routes.
 *
 * @example
 * \`\`\`tsx
 * import { paths } from "./routes.generated";
 *
 * // Static route
 * paths.for("/dashboard"); // → "/dashboard"
 *
 * // Dynamic route with parameters
 * paths.for("/orders/:id", { id: "123" }); // → "/orders/123"
 *
 * // With query string
 * paths.for("/orders/:id?tab=details", { id: "123" }); // → "/orders/123?tab=details"
 *
 * // Usage with navigation
 * const navigate = useNavigate();
 * navigate(paths.for("/orders/:id", { id: orderId }));
 *
 * // Usage with Link component
 * <Link to={paths.for("/dashboard")}>Dashboard</Link>
 * \`\`\`
 */
export const paths = createTypedPaths<GeneratedRouteParams>();

/**
 * Module augmentation for app-shell's type system.
 *
 * This augmentation registers the generated route parameters with app-shell,
 * allowing other app-shell features to reference these types.
 *
 * @example
 * \`\`\`tsx
 * import type { RouteParams } from "@tailor-platform/app-shell";
 *
 * // RouteParams is now typed as GeneratedRouteParams
 * type MyRoutes = keyof RouteParams; // "/", "/dashboard", "/orders/:id", etc.
 * \`\`\`
 */
declare module "@tailor-platform/app-shell" {
  interface AppShellRegister {
    routeParams: GeneratedRouteParams;
  }
}
`;
}
